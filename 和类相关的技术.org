* 默认构造函数
- 任何类都必须有默认构造函数
  - 如果提供了其他的构造函数，则必须提供默认构造函数
    - 默认构造函数允许使用接受参数的构造函数加上默认参数代替
  - 如果没提供构造函数，编译器可以自动生成默认构造函数，不建议这样

* 当类使用new时很重要的几个函数
下面几个函数可以由程序自动生成
** 复制构造函数
- 在以下几种情况将使用这个函数
  - 将新对象初始化为原来对象的一个副本
  - 按值传递对象到函数中
  - 函数按值返回对象
  - 编译器生成临时对象
- 如果显式定义函数行为，对于使用new的对象，浅复制会产生极其严重的后果
** 赋值运算符重载
- 初始化不是赋值
** 析构函数
- 注意析构函数中的 delete 与 new 对应，delete[] 与 new []对应
- 对于基类来说，提供一个虚析构函数很有必要

* 转换
其他类型和对象类型互转
** 其他类型->对象类型
- 主要由构造函数实现
  - =String(char *)= 大概长这个样子
  - 加上 =explicit= 关键字可以阻止隐式转化
** 对象类型->其他类型
- =operator typename ()= 原型长这样
  - typename换成目标类型，不接受任何参数
  - 加上 =explicit= 关键字之后还可以阻止隐式转换

* 传递参数类型
一般不建议按值传递，这样会调用赋值构造函数，很慢，而且派生类也无法使用
这些函数。

* const的用法
普通的const关键字用法很简单
- 关于对象的const
  - 大概长这样 =void String::Show()const=
  - 可以保证对象不会被

* 公有继承
** is-a 关系
公有继承表示了 is-a 关系，即“什么是一种特殊的什么”。
也就是说不能从 “大脑” 派生出 “人”。
** 不能被继承的方法
1. 构造函数
   - 这种函数即使是虚函数也没有意义，它一定会被派生类的构造函数调用的
   - c++11有一种能继承构造函数的机制
2. 析构函数
   - 每个派生类的析构函数都有自己是要干，即使没事也是调用基类析构函数
   - 一般析构函数都声明为虚函数
3. 赋值运算符
   - 它的特征标是随类变化而变化的，根本没有继承的必要
** 赋值运算符
如果派生类没有使用 =new= 的新成员，就不需要定义新的赋值运算符，编译器
将使用基类的赋值运算符
- 如何在派生类中定义赋值运算符
 - 举个例子
#+BEGIN_SRC C++
  hasDMA & hasDMA::operator = (const hasDMA & hs)
  {
    if(this == &hs)
      return *this;
    baseDMA::operator = (hs);
    delete[] style;
    style = new char[std::strlen(hs.style) + 1];
    std::strcpy(style, hs.style);
    return *this;
  }
#+END_SRC
- 有一句话很奇怪 =baseDMA::operator = (hs)= 
  - 它的意思大致为 =*this = hs=
  - 问题在于没法这样调用赋值运算符，因为这样的话编译器会不停调用
    =hasDMA::operator =()= 掉到一个死循环里面
  - 调用 =baseDAM= 的赋值运算符时，函数使用的  =this= 是 =hasDMA= 的
    =this=
** 保护成员 =protected=
 对派生类这部分的成员和 =public= 是一样的。
 对外部世界这部分成员和 =private= 是一样的。
** 虚方法
只将那些重定义的方法声明为虚函数就可以了
[[file:./Chapter13_类继承/类继承.org][虚方法的逻辑]]
** [[file:./Chapter13_类继承/类继承.org][友元函数的自我修养]]

