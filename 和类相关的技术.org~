* 默认构造函数
- 任何类都必须有默认构造函数
  - 如果提供了其他的构造函数，则必须提供默认构造函数
    - 默认构造函数允许使用接受参数的构造函数加上默认参数代替
  - 如果没提供构造函数，编译器可以自动生成默认构造函数，不建议这样

* 当类使用new时很重要的几个函数
下面几个函数可以由程序自动生成
** 复制构造函数
- 在以下几种情况将使用这个函数
  - 将新对象初始化为原来对象的一个副本
  - 按值传递对象到函数中
  - 函数按值返回对象
  - 编译器生成临时对象
- 如果显式定义函数行为，对于使用new的对象，浅复制会产生极其严重的后果
** 赋值运算符重载
- 初始化不是赋值
** 析构函数
- 注意析构函数中的 delete 与 new 对应，delete[] 与 new []对应
- 对于基类来说，提供一个虚析构函数很有必要

* 转换
其他类型和对象类型互转
** 其他类型->对象类型
- 主要由构造函数实现
  - =String(char *)= 大概长这个样子
  - 加上 =explicit= 关键字可以阻止隐式转化
** 对象类型->其他类型
- =operator typename ()= 原型长这样
  - typename换成目标类型，不接受任何参数
  - 加上 =explicit= 关键字之后还可以阻止隐式转换

* 传递参数类型
一般不建议按值传递，这样会调用赋值构造函数，很慢，而且派生类也无法使用
这些函数。

* const的用法
普通的const关键字用法很简单
- 关于对象的const
  - 大概长这样 =void String::Show()const=
  - 可以保证对象不会被

* 公有继承
** is-a 关系
公有继承表示了 is-a 关系，即“什么是一种特殊的什么”。
也就是说不能从 “大脑” 派生出 “人”。
** 不能被继承的方法
1. 构造函数
   - 这种函数即使是虚函数也没有意义，它一定会被派生类的构造函数调用的
   - c++11有一种能继承构造函数的机制
2. 析构函数
   - 每个派生类的析构函数都有自己是要干，即使没事也是调用基类析构函数
   - 一般析构函数都声明为虚函数
3. 赋值运算符
   - 它的特征标是随类变化而变化的，根本没有继承的必要
** 赋值运算符
如果派生类没有使用 =new= 的新成员，就不需要定义新的赋值运算符，编译器
将使用基类的赋值运算符
- 如何在派生类中定义赋值运算符
 - 举个例子
#+BEGIN_SRC C++

#+END_SRC
