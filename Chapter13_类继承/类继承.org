* 虚函数
1. 被关键字 =virtual= 声明的函数
2. 这种函数和普通的方法没什么区别，只有在使用指针或引用时才会有区别
   - 当基类指针或者引用指向一个派生类对象时，通过指针或者引用调用了一
     个虚函数，程序将调用对象所属类的函数，而不是指针或者引用所属类的
     函数
** 虚函数工作原理
1. 基类的虚函数会被储存在一个函数地址数组里，只有虚函数才会被存进去
2. 派生类也有一个存储函数地址的列表
   1. 新的被 =virtual= 关键字声明的函数地址
   2. 基类声明的虚函数的地址
      - 如果派生类重定义的虚函数，将会存入新函数的地址
3. 指针或引用将会读取对象的vtbl，查找对应的函数地址，并执行他
** 一些注意事项
1. 基类声明了虚函数，所有派生类相应的函数都是虚函数
2. 构造函数声明为虚函数毫无意义，因为派生类的构造函数将调用基类构造函
   数
3. 析构函数还是声明为虚函数，虚构对象用的就应该是对象所属类的析构函数
4. 重定义继承的方法时尽量不要修改接口，但是允许修改返回类型（这叫 返回
   类型协变）
   - 修改接口会隐藏原来的方法
   - 一个函数没什么，隐藏了就隐藏了
   - 如果是重载函数就麻烦了，除了重定义的那个函数以外，剩下的函数都会
     被隐藏，用不了啦
     - 解决方法是，重定义所有的重载函数，实现甚至可以是单纯的调用原来
       对应的基类函数


* 继承和动态内存分配
总的来说，每个类的的函数都只负责自己类特有的成员就好了
** 派生类不使用new
如果派生类不使用new，那么派生类就不需要特殊定义构造函数，复制函数，析
构函数，也不需要重载赋值运算符。
** 派生类使用new
派生类的函数只需要处理这个类特有的成员并调用基类的成员函数就可以了。

* 关于派生类的友元函数
** 问题主要体现在以下的推导中
1. 基类和派生类中都有友元函数，比如 =operator=()=
2. 利用友元函数可以访问对应类的私有成员
3. 派生类的友元函数是不能访问基类的友元函数的
4. 友元函数不能使用作用域解析运算符，它本身就不是类的成员函数
** 解决方法
强制类型转换，将对象的类型强制转换为基类类型，程序将调用相应的友元函数，
就像函数重载一样。
